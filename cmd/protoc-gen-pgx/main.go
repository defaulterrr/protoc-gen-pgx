package main

import (
	_ "embed"
	"fmt"
	"os"
	"strings"
	"text/template"

	pb "github.com/defaulterrr/protoc-gen-pgx/pb/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

//go:embed generated.template
var generatedTemplate string

func main() {
	protogen.Options{}.Run(func(p *protogen.Plugin) error {
		template, err := template.New("pgx").Parse(generatedTemplate)
		if err != nil {
			fmt.Fprintf(os.Stderr, "failed to parse template")
			panic(err)
		}

		annotatedMessages := []*protogen.Message{}

		for path, file := range p.FilesByPath {
			if strings.HasPrefix(path, "google/protobuf") {
				fmt.Fprintf(os.Stderr, "Skipping file %s\n", path)
				continue
			}

			fmt.Fprintf(os.Stderr, "Processing file %s\n", path)
			annotatedMessagesInFile := findAnnotatedMessages(file.Messages)

			annotatedMessages = append(annotatedMessages, annotatedMessagesInFile...)

			for _, ext := range file.Extensions {
				fmt.Fprintf(os.Stderr, "Message %s: %+v\n", ext.Desc.Name(), ext)
			}
		}

		fmt.Fprintf(os.Stderr, "will generate pgx for following types:\n")
		for _, message := range annotatedMessages {

			filename := fmt.Sprintf("%s.pgx.go", message.Desc.Name())

			tableName, ok := getTableName(message.Desc.Options().(*descriptorpb.MessageOptions))
			if !ok {
				fmt.Fprintf(os.Stderr, "%s – table not specified\n", message.Desc.FullName())
				continue
			}

			opts := templateOpts{
				Table: tableName,
			}

			for _, field := range message.Fields {
				name := string(field.Desc.Name())
				gotype := goTypeFromProtobuf(field)
				opts.Types = append(opts.Types, templateOptsTypeMeta{
					Name:   name,
					GoType: gotype,
				})
			}

			fmt.Fprintf(os.Stderr, "%s – table %s\n", message.Desc.FullName(), tableName)

			file := p.NewGeneratedFile(filename, message.GoIdent.GoImportPath)
			file.Write([]byte("// DO NOT EDIT: file generated by protoc-gen-pgx\n"))
			file.P("package pgxpb\n")

			file.P("import \"" + "github.com/jackc/pgx/v5/pgxpool" + "\"")
			file.P("import \"" + "github.com/jackc/pgx/v5" + "\"")
			file.P("import \"" + "context" + "\"")
			file.P("import \"" + "fmt" + "\"")

			if err := template.Execute(file, opts); err != nil {
				fmt.Fprintf(os.Stderr, "failed to execute and write template to new file: %v", err)
				panic(err)
			}
		}

		return nil
	})
}

func findAnnotatedMessages(messages []*protogen.Message) []*protogen.Message {
	annotatedMessages := []*protogen.Message{}

	for _, message := range messages {
		if shouldGenerate(message.Desc.Options().(*descriptorpb.MessageOptions)) {
			annotatedMessages = append(annotatedMessages, message)
		}
	}

	return annotatedMessages
}

func shouldGenerate(in *descriptorpb.MessageOptions) bool {
	if in == nil {
		return false
	}

	v := proto.GetExtension(in, pb.E_ShouldGenerate)
	if v == nil {
		return false
	}

	shouldGenerate, ok := v.(bool)
	if !ok {
		return false
	}
	return shouldGenerate
}

func getTableName(in *descriptorpb.MessageOptions) (string, bool) {
	if in == nil {
		return "", false
	}

	v := proto.GetExtension(in, pb.E_TableName)
	if v == nil {
		return "", false
	}

	shouldGenerate, ok := v.(string)
	return shouldGenerate, ok
}

type MessageOptions struct {
	tableName string
}

func goTypeFromProtobuf(in *protogen.Field) string {
	return in.Desc.Kind().String()
}

type templateOpts struct {
	Types []templateOptsTypeMeta
	Table string
}

type templateOptsTypeMeta struct {
	Name   string
	GoType string
}
